# 进程的终止：_exit()和exit()
- 进程终止方式：
    1. 异常（abnormal）终止
        - 由对一信号的接收而引发，该信号的默认动作为终止当前进程，**可能产生核心转储（core dump）**
    2. 使用_exit()系统调用正常（normally）终止

> **`void _exit(int status);`**--->系统调用
> #include<unistd.h>

- status 参数定义了进程的终止状态（termination  status），父进程可调用 wait()以获取该状态
  - > `pid_t wait(int *status);`
    - wait()函数会阻塞调用进程，直到有一个子进程终止。
    - **status参数是一个指向整型的指针，用于获取子进程的退出状态**。
    - 如果当前没有子进程，wait()函数会立即返回-1，并且errno被设置为ECHILD。
    - 如果有一个子进程终止，则wait()函数会返回该子进程的pid，**并将退出状态存储到status指向的变量中**。
    - 可以使用waitpid()函数来等待指定的子进程终止。
  - **_exit(0)表示进程成功退出**
  - **_exit(非0值)表示异常退出**
  - status定义为int 类型，但**仅有低8 位可为父进程所用**，且取值大于128 将在shell 脚本中引发混乱
    - 原因：当以信号（signal）终止一命令时，shell 会将变量$?置为 128 与信号值之和

> **`void exit(int status);`**--->库函数调用
> #include<stdlib.h>

- 程序一般不会直接调用_exit()，而是**调用库函数 exit()**，它**会在调用_exit()前执行各种动作**
    - exit()会执行的动作如下：
      - 调用退出处理程序（通过 atexit()和 on_exit()注册的函数），其执行顺序与注册顺序相反
      - 刷新stdio 流缓冲区
      - 使用由status 提供的值执行_exit()系统调用

- 执行return n **等同于**执行对exit(n)的调用
  
---
# 进程终止的细节
- 无论进程是否正常终止，都会发生如下动作
    1. 关闭所有打开文件描述符、目录流、信息目录描述符），以及（字符集）转换描述符
    2. 作为文件描述符关闭的后果之一，将释放该进程所持有的任何文件锁
    3. 分离（detach）任何已连接的System V 共享内存段，且对应于各段的shm_nattch 计数器值将减一
    4. 进程为每个System V 信号量所设置的semadj 值将会被加到信号量值中
    5. 如果该进程是一个管理终端（terminal ）的管理进程，那么系统会向该终端前台（foreground）进程组中的每个进程发送SIGHUP 信号，接着终端会与会话（session）脱离
    6. 将关闭该进程打开的任何POSIX 有名信号量，类似于调用sem_close()
    7. 将关闭该进程打开的任何POSIX 消息队列，类似于调用mq_close()。
    8. 作为进程退出的后果之一，如果某进程组成为孤儿，且该组中存在任何已停止进程（stopped processes），则组中所有进程都将收到SIGHUP 信号，随之为SIGCONT 信号
    9. 移除该进程通过mlock()或mlockall()所建立的任何内存锁
    10. 取消该进程调用mmap()所创建的任何内存映射（mapping）

---
# 退出处理程序
P442

---
# fork()、stdio 缓冲区以及_exit()之间的交互

