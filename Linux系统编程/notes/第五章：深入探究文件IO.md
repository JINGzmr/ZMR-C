5.2——5.5
- [文件控制操作：fcntl()](#文件控制操作fcntl)
- [打开文件的状态标志](#打开文件的状态标志)
  - [获取打开文件的状态标志(F\_GETFL)](#获取打开文件的状态标志f_getfl)
  - [判定文件的访问模式](#判定文件的访问模式)
  - [修改打开文件的状态标志(F\_SETFL)](#修改打开文件的状态标志f_setfl)
- [文件描述符和打开文件之间的关系](#文件描述符和打开文件之间的关系)
  - [打开文件的描述符（open file descriptor）表](#打开文件的描述符open-file-descriptor表)
  - [描述表格（open file description  table）- 打开文件表（open file table）](#描述表格open-file-description--table--打开文件表open-file-table)
  - [i-node 表](#i-node-表)
  - [文件描述符、打开的文件句柄以及i-node 之间的关系](#文件描述符打开的文件句柄以及i-node-之间的关系)(有图)
    - [结论：](#结论)
- [复制文件描述符](#复制文件描述符)
  - [dup()](#dup)
  - [dup2()](#dup2)
  - [fcntl()的F\_DUPFD 操作](#fcntl的f_dupfd-操作)
  - [dup3()](#dup3)
  - [总结：](#总结)

# 文件控制操作：fcntl()
![](2023-02-10-11-11-18.png)
>**int fcntl(int fd, int cmd, ...);**
- cmd: 控制操作，且所支持的操作范围很广
- ...：依据cmd 参数（如果有的话）的值来确定该参数的数据类型`有时候可以省略`

---
# 打开文件的状态标志
 - fcntl()的用途之一：针对一个打开的文件，`获取或修改`其**访问模式和状态标志**
     - *访问模式和状态标志*是通过指定open()调用的**flag 参数**来设置的
  
## 获取打开文件的状态标志(F_GETFL)
- 将fcntl()的**cmd** 参数设置为**F_GETFL**
- ![](2023-02-10-13-31-39.png)
     - 注：针对一个打开的文件，*只有*通过open()或后续fcntl()的F_SETFL 操作，*才能*对该文件的状态标志进行设置

## 判定文件的访问模式
- 因为O_RDONLY(0)、O_WRONLY(1)和O_RDWR(2)这3 个常量并**不与**打开文件状态标志中的单个比特位对应
- 因此，要判定访问模式，需使用掩码O_ACCMODE 与flag **`相与`(&)**，将结果与3 个常量进行比对
- ![](2023-02-10-13-37-15.png)
  

## 修改打开文件的状态标志(F_SETFL)
- 使用 fcntl()的 F_SETFL 命令来修改
- 允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和O_DIRECT
- 适用场景:
    -  文件**不是**由调用程序打开的，所以程序也 **无法使用open()** 调用来控制文件的状态标志`(文件是 3 个标准输入输出描述符中的一员，这些描述符在程序启动之前就被打开)`
    -  文件描述符的获取是通过 **open()之外的系统调用** 
          -  例如：pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端
          -  再比如：socket()调用，该调用创建一个套接字并返回指向该套接字的文件描述符
- 操作：
    1. 使用fcntl()的`F_GETFL` 命令来**获取当前标志的副本**
    2. **修改需要变更的比特位**
    3. 再次调用fcntl()函数的 `F_SETFL` 命令来**更新此状态标志**
    -  添加O_APPEND 标志的代码如下
   - ![](2023-02-10-14-41-28.png)


---
# 文件描述符和打开文件之间的关系
- 多个文件描述符指向同一打开文件，这些文件描述符可在相同或不同的进程中打开
- 由内核维护的3 个数据结构：
    1. 进程级的**文件描述符表**
    2. 系统级的**打开文件表**
    3. 文件系统的**i-node 表**
   
## 打开文件的描述符（open file descriptor）表
- 该表的每一条目都记录了**单个文件描述符的相关信息**
    - 控制文件描述符操作的一组标志（仅定义了一个，即close-on-exec 标志）
    - 对打开文件句柄的引用

## 描述表格（open file description  table）- 打开文件表（open file table）
- 表中各条目称为打开文件句柄（open file handle）
- `一个打开文件句柄`存储了**与一个打开文件相关的全部信息**
    1. `当前文件偏移量`（调用read()和write()时更新，或使用lseek()直接修改）
    2. 打开文件时所使用的`状态标志`（即，open()的flags 参数）
    3. `文件访问模式`（如调用open()时所设置的只读模式、只写模式或读写模式）
    4. 与信号驱动I/O 相关的设置
    5. 对该文件`i-node 对象的引用`

## i-node 表
- 每个文件系统都会为驻留其上的**所有文件**建立一个 i-node 表
    1. `文件类型`（例如，常规文件、套接字或FIFO）和`访问权限`
    2. `一个指针`，指向该文件所持有的锁的列表
    3. `文件的各种属性`，包括文件大小以及与不同类型操作相关的时间戳

## 文件描述符、打开的文件句柄以及i-node 之间的关系
![](2023-02-10-15-12-25.png)
- 在`进程A` 中，文件`描述符1` 和`20` 都指向**同一个打开的文件句柄**（标号为23）。
    - 这可能是通过调用dup()、dup2()或fcntl()而形成的
- `进程A` 的文件`描述符2` 和`进程B `的文件`描述符2` 都指向**同一个打开的文件句柄**（标号为73）。
    - 这种情形可能在调用fork()后出现（即，进程A 与进程B 之间是父子关系）
    - 或者当某进程通过UNIX 域套接字将一个打开的文件描述符传递给另一进程时
- `进程A` 的`描述符0` 和`进程B` 的`描述符3` 分别指向**不同的打开文件句柄**，但这些句柄均指向**i-node 表中的相同条目**（1976）->>即**指向同一文件** 
    - 每个进程各自对同一文件发起了open()调用
    - 同一个进程两次打开同一文件

### 结论：
1. **两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量**
   - 因此，如果通过其中一个文件描述符来修改文件偏移量`（由调用 read()、write()或 lseek()所致）`，那么从另一文件描述符中也会观察到这一变化。`无论这两个文件描述符分属于不同进程，还是同属于一个进程`
2. **要获取和修改打开的文件标志**`（例如，O_APPEND、O_NONBLOCK 和 O_ASYNC）`，**可执行fcntl()的F_GETFL 和F_SETFL 操作**，
    - 其对作用域的约束与上一条颇为类似。
3. **文件描述符标志（*close-on-exec 标志*）为进程和文件描述符所私有。**
    - 对这一标志的修改将**不会影响**同一进程或不同进程中的其他文件描述符

---
# 复制文件描述符
- ![](2023-02-11-11-41-20.png)
- shell 通过复制文件描述符2`将文件描述符1 复制到文件描述符2`实现了**标准错误的重定向操作**
    - 因此文件描述符2 与文件描述符1 **指向同一个打开文件句柄**
        - （像图5-2 中进程A 的描述符1 和20 指向同一打开文件句柄的情况）
    - 通过**调用dup()和dup2()来实现**此功能
    - 注：要满足shell 的这一要求，仅仅简单地`打开results.log 文件两次是远远不够的`（第一次在描述符1 上打开，第二次在描述符2 上打开）
        1. 两个文件描述符`不能共享相同的文件偏移量指针`，因此有可能导致相互覆盖彼此的输出
        2. 打开的文件`不一定就是磁盘文件`
        3. ![](2023-02-11-11-47-50.png)

## dup()
![](2023-02-11-11-49-12.png)
> **int dup(int oldfd);**
- **复制一个打开的文件描述符oldfd**，并**返回一个新描述符**，二者都**指向同一打开的文件句柄**
- **新描述符**一定是**编号值最低**的**未用**文件描述符
- 例：![](2023-02-11-11-53-23.png)
- 若要dup返回描述符2，则：**先关闭文件描述符为2的文件**，再调用dup![](2023-02-11-11-55-44.png)![](2023-02-11-12-01-29.png)也ok

## dup2()
![](2023-02-11-12-32-48.png)
> **int dup2(int oldfd, int newfd);**
- dup2()系统调用会**为oldfd 参数所指定的文件描述符创建副本**，其**编号由newfd 参数指定**
- **如果由newfd 参数所指定编号的文件描述符之前已经打开**，那么dup2()**会首先将其关闭**
    - but:dup2()调用会默然*忽略* newfd 关闭期间出现的任何错误
    - 安全做法：在调用dup2()之前，若newfd 已经打开，则应*显式调用close()将其关闭*
- 返回值：
    - 成功：返回**副本的**文件描述符编号（即**newfd 参数指定的值**）
    - 若 oldfd `并非有效`的文件描述符，失败并返回错误 EBADF，不会关闭newfd
    - 若 oldfd `有效`，`且与newfd 值相等`，那么 dup2()将什么也不做，不关闭newfd，并将其作为调用结果返回

## fcntl()的F_DUPFD 操作
![](2023-02-11-12-11-38.png)
> **newfd = fcntl(old,F_DUPFD, startfd);**
- 该调用为oldfd 创建一个副本，且将**使用*大于等于*startfd 的`最小未用值`作为描述符编号**
- 能保证新描述符（newfd）编号落在特定的区间范围内
- 总是能将 dup()和 dup2()调用改写为对 close()和 fcntl()的调用 -> close就是先关闭`想要设置的副本文件描述符所对应的已打开的那个文件`啦
- ![](2023-02-11-12-31-27.png)

## dup3()
-前言：新文件描述符有其自己的一套**文件描述符标志**`图 5-2`，且其 close-on-exec 标志（FD_CLOEXEC）总是处于关闭状态。下面将要介绍的接口，**可以直接控制新文件描述符的close-on-exec 标志**
![](2023-02-11-12-20-21.png)
> **int dup3(int oldfd, int newfd, int flags);**
- dup3()系统调用完成的工作**与dup2()相同**，只是**新增了一个附加参数flag**，**可以修改系统调用行为的位掩码**`-> flag见第四章open()`
- dup3()只支持一个标志 O_CLOEXEC，这将**促使内核为新文件描述符设置 close-on-exec 标志（FD_CLOEXEC）**


## 总结：
 1. 由图 5-2 可知，**文件描述符的正、副本**之间**共享同一打开文件句柄所含的文件偏移量和状态标志**
 2. 副本是由dup系列函数调用产生的，**正、副本的文件描述符不同**